"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var MetadataRepository = function () {
    function MetadataRepository(metadataLoader) {
        _classCallCheck(this, MetadataRepository);

        this.repositoryData = {};
        this.metadataLoader = metadataLoader;
    }

    _createClass(MetadataRepository, [{
        key: "getDataItemByKey",
        value: function getDataItemByKey(key, theme) {
            var result = null;
            var themeData = this.repositoryData[theme.name + "-" + theme.colorScheme];

            for (var i = 0; i < themeData.length; i++) {
                if (themeData[i].Key === key) {
                    result = themeData[i];
                    break;
                }
            }

            return result;
        }
    }, {
        key: "init",
        value: function init(themes) {
            var _this = this;

            var promises = [];

            themes.forEach(function (theme) {
                promises.push(new Promise(function (resolve) {
                    _this.metadataLoader.load(theme.name, theme.colorScheme).then(function (metadata) {
                        _this.repositoryData[theme.name + "-" + theme.colorScheme] = metadata;
                        resolve();
                    });
                }));
            });

            return Promise.all(promises);
        }
    }, {
        key: "getData",
        value: function getData(theme) {
            if (!theme) return this.repositoryData;
            return this.repositoryData[theme.name + "-" + theme.colorScheme];
        }
    }, {
        key: "updateData",
        value: function updateData(data, theme) {
            var _this2 = this;

            data.forEach(function (item) {
                var dataItem = _this2.getDataItemByKey(item.key, theme);
                if (item) dataItem.Value = item.value;
            });
        }
    }, {
        key: "getVersion",
        value: function getVersion() {
            return this.metadataLoader.version();
        }
    }]);

    return MetadataRepository;
}();

module.exports = MetadataRepository;